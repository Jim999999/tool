1.使用Concurrent集合
  1).通过ReentrantLock和Condition实现了一个BlockingQueue：
		public class TaskQueue {
			private final Lock lock = new ReentrantLock();
			private final Condition condition = lock.newCondition();
			private Queue<String> queue = new LinkedList<>();

			public void addTask(String s) {
				lock.lock();
				try {
					queue.add(s);
					condition.signalAll();
				} finally {
					lock.unlock();
				}
			}

			public String getTask() {
				lock.lock();
				try {
					while (queue.isEmpty()) {
						condition.await();
					}
					return queue.remove();
				} finally {
					lock.unlock();
				}
			}
		}
   2).BlockingQueue即是当一个线程调用这个TaskQueue的getTask()方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，getTask()方法才会返回。
   3).Java标准库的java.util.concurrent包提供的线程安全的集合
		interface				non-thread-safe						thread-safe
		List					ArrayList							CopyOnWriteArrayList
		Map						HashMap								ConcurrentHashMap
		Set						HashSet / TreeSet					CopyOnWriteArraySet
		Queue					ArrayDeque / LinkedList				ArrayBlockingQueue / LinkedBlockingQueue
		Deque					ArrayDeque / LinkedList				LinkedBlockingDeque
   4).使用java.util.concurrent包提供的线程安全的并发集合可以大大简化多线程编程： 
		Map<String, String> map = new ConcurrentHashMap<>();
		// 在不同的线程读写:
		map.put("A", "1");
		map.put("B", "2");
		map.get("A", "1");

2.使用Atomic
  1).Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。
  2).以AtomicInteger为例，它提供的主要操作有：
		增加值并返回新值：int addAndGet(int delta)
		加1后返回新值：   int incrementAndGet()
		获取当前值：      int get()
		用CAS方式设置：   int compareAndSet(int expect, int update)
   3).CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do ... while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。
		public int incrementAndGet(AtomicInteger var) {
			int prev, next;
			do {
				prev = var.get();
				next = prev + 1;
			} while ( ! var.compareAndSet(prev, next));  // 如果AtomicInteger的当前值是prev，那么就更新为next，返回true , 否则什么也不干，返回false
			return next;
		}

3.使用线程池
   1).这种能接收大量小任务并进行分发处理的就是线程池。
   2).简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。
   3).Java标准库提供了 ExecutorService 接口表示线程池，它的典型用法如下：
		// 创建固定大小的线程池:
		ExecutorService executor = Executors.newFixedThreadPool(3);
		// 提交任务:
		executor.submit(task1);
		executor.submit(task2);
		executor.submit(task3);
		executor.submit(task4);
		executor.submit(task5);
   4).因为ExecutorService只是接口，Java标准库提供的几个常用实现类有：
		FixedThreadPool：线程数固定的线程池；
		CachedThreadPool：线程数根据任务动态调整的线程池；
		SingleThreadExecutor：仅单线程执行的线程池。
   5).线程池在程序结束的时候要关闭。
		// 创建一个固定大小的线程池:
        ExecutorService es = Executors.newFixedThreadPool(4);
        // 关闭线程池:
        es.shutdown();
      注意，使用shutdown()方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。shutdownNow()会立刻停止正在执行的任务，awaitTermination()则会等待指定的时间让线程池关闭。

		import java.util.concurrent.*;
		public class Main {
			public static void main(String[] args) {
				// 创建一个固定大小的线程池:
				ExecutorService es = Executors.newFixedThreadPool(4);
				for (int i = 0; i < 6; i++) {
					es.submit(new Task("" + i));
				}
				// 关闭线程池:
				es.shutdown();
			}
		}

		class Task implements Runnable {
			private final String name;

			public Task(String name) {
				this.name = name;
			}

			@Override
			public void run() {
				System.out.println("start task " + name);
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
				}
				System.out.println("end task " + name);
			}
		}

	6).定期反复执行 ScheduledThreadPool , 放入ScheduledThreadPool的任务可以定期反复执行。
		6.1).创建一个ScheduledThreadPool仍然是通过Executors类：
			ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);
			// 1秒后执行一次性任务:
			ses.schedule(new Task("one-time"), 1, TimeUnit.SECONDS);
			// 2秒后开始执行定时任务，每3秒执行:
			ses.scheduleAtFixedRate(new Task("fixed-rate"), 2, 3, TimeUnit.SECONDS);
			// 2秒后开始执行定时任务，以3秒为间隔执行:
			ses.scheduleWithFixedDelay(new Task("fixed-delay"), 2, 3, TimeUnit.SECONDS);
        6.2).注意FixedRate和FixedDelay的区别。
			FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间(不管任务执行有无完成)：
			而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：
        6.3).Java标准库还提供了一个java.util.Timer类，
			这个类也可以定期执行任务，但是，一个Timer会对应一个Thread，所以，一个Timer只能定期执行一个任务，多个定时任务必须启动多个Timer，
			而一个ScheduledThreadPool就可以调度多个定时任务，所以，我们完全可以用ScheduledThreadPool取代旧的Timer。

4.使用Callable
  1).在执行多个任务的时候，经常需要实现runnable接口，但该接口没有返回值，此时用Callable代替即可用返回值返回需要的数据.
		class Task implements Callable<String> {
			public String call() throws Exception {
				return longTimeCalculation(); 
			}
		}
   2).Callable接口是一个泛型接口，可以返回指定类型的结果。
   3).获得Callable异步执行的结果，可以用future类型。
   
5.使用Future
  1).ExecutorService.submit()方法，返回的是一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：
		ExecutorService executor = Executors.newFixedThreadPool(4); 
		// 定义任务:
		Callable<String> task = new Task();
		// 提交任务并获得Future:
		Future<String> future = executor.submit(task);
		// 从Future获取异步执行返回的结果:
		String result = future.get(); // 可能阻塞
   2).当提交一个Callable任务后，会同时获得一个Future对象，在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。
   3).一个Future<V>接口表示一个未来可能会返回的结果，它定义的方法有：
		get()：获取结果（可能会等待）
		get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；
		cancel(boolean mayInterruptIfRunning)：取消当前任务；
		isDone()：判断任务是否已完成。
   4).使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。

6.使用CompletableFuture






















































