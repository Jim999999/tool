1.使用Concurrent集合
  1).通过ReentrantLock和Condition实现了一个BlockingQueue：
		public class TaskQueue {
			private final Lock lock = new ReentrantLock();
			private final Condition condition = lock.newCondition();
			private Queue<String> queue = new LinkedList<>();

			public void addTask(String s) {
				lock.lock();
				try {
					queue.add(s);
					condition.signalAll();
				} finally {
					lock.unlock();
				}
			}

			public String getTask() {
				lock.lock();
				try {
					while (queue.isEmpty()) {
						condition.await();
					}
					return queue.remove();
				} finally {
					lock.unlock();
				}
			}
		}
   2).BlockingQueue即是当一个线程调用这个TaskQueue的getTask()方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，getTask()方法才会返回。
   3).Java标准库的java.util.concurrent包提供的线程安全的集合
		interface				non-thread-safe						thread-safe
		List					ArrayList							CopyOnWriteArrayList
		Map						HashMap								ConcurrentHashMap
		Set						HashSet / TreeSet					CopyOnWriteArraySet
		Queue					ArrayDeque / LinkedList				ArrayBlockingQueue / LinkedBlockingQueue
		Deque					ArrayDeque / LinkedList				LinkedBlockingDeque
   4).使用java.util.concurrent包提供的线程安全的并发集合可以大大简化多线程编程： 
		Map<String, String> map = new ConcurrentHashMap<>();
		// 在不同的线程读写:
		map.put("A", "1");
		map.put("B", "2");
		map.get("A", "1");

2.使用Atomic
  1).Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。
  2).以AtomicInteger为例，它提供的主要操作有：
		增加值并返回新值：int addAndGet(int delta)
		加1后返回新值：   int incrementAndGet()
		获取当前值：      int get()
		用CAS方式设置：   int compareAndSet(int expect, int update)
   3).CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do ... while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。
		public int incrementAndGet(AtomicInteger var) {
			int prev, next;
			do {
				prev = var.get();
				next = prev + 1;
			} while ( ! var.compareAndSet(prev, next));  // 如果AtomicInteger的当前值是prev，那么就更新为next，返回true , 否则什么也不干，返回false
			return next;
		}

3.使用线程池
   1).这种能接收大量小任务并进行分发处理的就是线程池。
   2).简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。
   3).Java标准库提供了 ExecutorService 接口表示线程池，它的典型用法如下：
		// 创建固定大小的线程池:
		ExecutorService executor = Executors.newFixedThreadPool(3);
		// 提交任务:
		executor.submit(task1);
		executor.submit(task2);
		executor.submit(task3);
		executor.submit(task4);
		executor.submit(task5);
   4).因为ExecutorService只是接口，Java标准库提供的几个常用实现类有：
		FixedThreadPool：线程数固定的线程池；
		CachedThreadPool：线程数根据任务动态调整的线程池；
		SingleThreadExecutor：仅单线程执行的线程池。






































































