反射
1.反射就是Reflection，Java的反射是指程序在运行期就可以拿到一个对象的所有信息。
2.通过Class实例(该实例为JVM创建的且类名为Class的实例)获取class信息的方法称为反射（Reflection）。

Class类
1.除了int等基本类型外，Java的其他类型全部都是class（包括interface）：
	String，Object，Runnable，Exception，...
2.每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class：
	public final class Class {
		private Class() {}
	}
  以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来：
  Class cls = new Class(String);  //注意，Class 是上述类的类名
3.获取一个class的Class实例（JVM为其创建的Class类型实例）？有三个方法：
  1).直接通过一个class的静态变量class获取：
	Class cls = String.class;  // class java.lang.String
  2).通过实例变量提供的 getClass()方法获取：
	String s = "Hello";
	Class cls = s.getClass(); // class java.lang.String
  3).通过完整类名调用静态方法 Class.forName()获取：
	Class cls = Class.forName("java.lang.String");
4.获取到了一个Class实例，就可以通过该Class实例来创建对应类型的实例：
	// 获取String的Class实例:
	Class cls = String.class;
	// 创建一个String实例:
	String s = (String) cls.newInstance();
	上述代码相当于new String()，通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。

访问字段
1.对任意的一个Object实例，只要获取了它的Class，就可以获取它的一切信息。
	Class类提供了以下几个方法来获取字段：
		Field   getField(name)：根据字段名获取某个public的field（包括父类）
		Field   getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
		Field[] getFields()：获取所有public的field（包括父类）
		Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）
		
3.用反射获取该字段的信息：
	Field f = String.class.getDeclaredField("value");
	f.getName(); // "value"
	f.getType(); // class [B 表示byte[]类型
	int m = f.getModifiers();
	Modifier.isFinal(m); // true
	Modifier.isPublic(m); // false
	Modifier.isProtected(m); // false
	Modifier.isPrivate(m); // true
	Modifier.isStatic(m); // false
4.用 Field.get(Object)获取指定实例的指定字段的值。	
	Object p = new Person("Xiao Ming");
	Class c = p.getClass(); // Person.class;
	Field f = c.getDeclaredField("name");
	Object value = f.get(p);
	System.out.println(value); // "Xiao Ming"
5.通过Field.set(Object, Object)设置字段值
	Person p = new Person("Xiao Ming");
	System.out.println(p.getName()); // "Xiao Ming"
	Class c = p.getClass();
	Field f = c.getDeclaredField("name");
	f.setAccessible(true); //修改非public字段，需要首先调用setAccessible(true)
	f.set(p, "Xiao Hong");
	System.out.println(p.getName()); // "Xiao Hong"

6.通过Class实例获取所有Method信息
	Method getMethod(name, Class...)：获取某个public的Method（包括父类）
	Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）
	Method[] getMethods()：获取所有public的Method（包括父类）
	Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）
 1).通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 
	 Class stdClass = Student.class;
	 stdClass.getMethod("getScore", String.class)  // getMethod("函数名", 参数)
 2).通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()；
 3).通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)；
 4).通过设置setAccessible(true)来访问非public方法；
 5).通过反射调用方法时，仍然遵循多态原则。

7.调用构造方法
 通过Class实例获取Constructor的方法如下：
	getConstructor(Class...)：获取某个public的Constructor；返回实例。
	getDeclaredConstructor(Class...)：获取某个Constructor；
	getConstructors()：获取所有public的Constructor；
	getDeclaredConstructors()：获取所有Constructor。
 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。
 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。

	// 获取构造方法Integer(int):
	Constructor cons1 = Integer.class.getConstructor(int.class); //返回实例
	// 调用构造方法:
	Integer n1 = (Integer) cons1.newInstance(123);
	System.out.println(n1);

8.获取父类的Class
 1).通过Class对象可以获取继承关系：
	Class getSuperclass()：获取父类类型；
		Class i = Integer.class;
        Class n = i.getSuperclass(); 
	Class[] getInterfaces()：获取当前类实现的所有接口。
		Class s = Integer.class;
        Class[] is = s.getInterfaces();
        for (Class i : is) {
            System.out.println(i);
        }
 2).对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()：
 3).如果一个类没有实现任何interface，那么getInterfaces()返回空数组。	
 4).通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。
 
注解（Annotation）
1.注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：







































