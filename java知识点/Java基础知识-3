反射
1.反射就是Reflection，Java的反射是指程序在运行期就可以拿到一个对象的所有信息。
2.通过Class实例(该实例为JVM创建的且类名为Class的实例)获取class信息的方法称为反射（Reflection）。

Class类
1.除了int等基本类型外，Java的其他类型全部都是class（包括interface）：
	String，Object，Runnable，Exception，...
2.每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class：
	public final class Class {
		private Class() {}
	}
  以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来：
  Class cls = new Class(String);  //注意，Class 是上述类的类名
3.获取一个class的Class实例（JVM为其创建的Class类型实例）？有三个方法：
  1).直接通过一个class的静态变量class获取：
	Class cls = String.class;  // class java.lang.String
  2).通过实例变量提供的 getClass()方法获取：
	String s = "Hello";
	Class cls = s.getClass(); // class java.lang.String
  3).通过完整类名调用静态方法 Class.forName()获取：
	Class cls = Class.forName("java.lang.String");
4.获取到了一个Class实例，就可以通过该Class实例来创建对应类型的实例：
	// 获取String的Class实例:
	Class cls = String.class;
	// 创建一个String实例:
	String s = (String) cls.newInstance();
	上述代码相当于new String()，通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。

访问字段
1.对任意的一个Object实例，只要获取了它的Class，就可以获取它的一切信息。
	Class类提供了以下几个方法来获取字段：
		Field   getField(name)：根据字段名获取某个public的field（包括父类）
		Field   getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
		Field[] getFields()：获取所有public的field（包括父类）
		Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）
		
3.用反射获取该字段的信息：
	Field f = String.class.getDeclaredField("value");
	f.getName(); // "value"
	f.getType(); // class [B 表示byte[]类型
	int m = f.getModifiers();
	Modifier.isFinal(m); // true
	Modifier.isPublic(m); // false
	Modifier.isProtected(m); // false
	Modifier.isPrivate(m); // true
	Modifier.isStatic(m); // false
4.用 Field.get(Object)获取指定实例的指定字段的值。	
	Object p = new Person("Xiao Ming");
	Class c = p.getClass(); // Person.class;
	Field f = c.getDeclaredField("name");
	Object value = f.get(p);
	System.out.println(value); // "Xiao Ming"
5.通过Field.set(Object, Object)设置字段值
	Person p = new Person("Xiao Ming");
	System.out.println(p.getName()); // "Xiao Ming"
	Class c = p.getClass();
	Field f = c.getDeclaredField("name");
	f.setAccessible(true); //修改非public字段，需要首先调用setAccessible(true)
	f.set(p, "Xiao Hong");
	System.out.println(p.getName()); // "Xiao Hong"

6.通过Class实例获取所有Method信息
	Method getMethod(name, Class...)：获取某个public的Method（包括父类）
	Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）
	Method[] getMethods()：获取所有public的Method（包括父类）
	Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）
 1).通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 
	 Class stdClass = Student.class;
	 stdClass.getMethod("getScore", String.class)  // getMethod("函数名", 参数)
 2).通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()；
 3).通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)；
 4).通过设置setAccessible(true)来访问非public方法；
 5).通过反射调用方法时，仍然遵循多态原则。

7.调用构造方法
 通过Class实例获取Constructor的方法如下：
	getConstructor(Class...)：获取某个public的Constructor；返回实例。
	getDeclaredConstructor(Class...)：获取某个Constructor；
	getConstructors()：获取所有public的Constructor；
	getDeclaredConstructors()：获取所有Constructor。
 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。
 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。

	// 获取构造方法Integer(int):
	Constructor cons1 = Integer.class.getConstructor(int.class); //返回实例
	// 调用构造方法:
	Integer n1 = (Integer) cons1.newInstance(123);
	System.out.println(n1);

8.获取父类的Class
 1).通过Class对象可以获取继承关系：
	Class getSuperclass()：获取父类类型；
		Class i = Integer.class;
        Class n = i.getSuperclass(); 
	Class[] getInterfaces()：获取当前类实现的所有接口。
		Class s = Integer.class;
        Class[] is = s.getInterfaces();
        for (Class i : is) {
            System.out.println(i);
        }
 2).对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()：
 3).如果一个类没有实现任何interface，那么getInterfaces()返回空数组。	
 4).通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。
 
注解（Annotation）
  定义：
	1.注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：
	2.注解（Annotation）是Java语言用于工具处理的标注：
	3.注解可以配置参数，没有指定配置的参数使用默认值；
	4.如果参数名称是value，且只有一个参数，那么可以省略参数名称。
	5.Java使用@interface定义注解：
	6.可定义多个参数和默认值，核心参数使用value名称；
	7.必须设置@Target来指定Annotation可以应用的范围；
	8.应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。
  处理：
	1.根据@Retention的配置：
		1).SOURCE类型的注解在编译期就被丢掉了，主要由编译器使用；
		2).CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM，主要由底层工具库使用；
		3).RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取，RUNTIME类型注解不但要使用，还经常需要编写。  
	2.注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。
		2.2.Java提供的使用反射API读取Annotation的方法包括：
		判断某个注解是否存在于Class、Field、Method或Constructor：
		Class.isAnnotationPresent(Class)
			// 判断@Report是否存在于Person类:
			Person.class.isAnnotationPresent(Report.class);
		Field.isAnnotationPresent(Class)
		Method.isAnnotationPresent(Class)
		Constructor.isAnnotationPresent(Class)

		2.3.使用反射API读取Annotation：
		Class.getAnnotation(Class)
		Field.getAnnotation(Class)
		Method.getAnnotation(Class)
		Constructor.getAnnotation(Class)
			// 获取Person定义的@Report注解:
			Report report = Person.class.getAnnotation(Report.class);
			int type = report.type();
			String level = report.level();
		2.4.使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取：
			Class cls = Person.class;
			if (cls.isAnnotationPresent(Report.class)) {
				Report report = cls.getAnnotation(Report.class);
				...
			}
		2.5.第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：
			Class cls = Person.class;
			Report report = cls.getAnnotation(Report.class);
			if (report != null) {
			   ...
			}

泛型（“代码模板”）
1.泛型是定义一种模板，例如ArrayList<T>，在代码中为用到的类创建对应的ArrayList<类型>：
	ArrayList<String> strList = new ArrayList<String>();
2.向上转型，在Java标准库中的ArrayList<T>实现了List<T>接口，它可以向上转型为List<T>：
	List<String> list = new ArrayList<String>();
	要特别注意：不能把ArrayList<Integer>向上转型为ArrayList<Number>或List<Number>。
























